---
title: "brms_week3_HW"
author: "Min-Yao"
date: "2020/9/9"
output: 
  html_document: 
    keep_md: yes
---

```{r}
library(rethinking)
library(brms)
library(tidyverse)
```

```{r}
data <- read_csv("light_round1_tall.csv")
head(data)
summary(data)
str(data)
```
The Maloof, Gremer, Schmitt, and Strauss labs have a joint project examining variation in life history traits and adaptation in a group of Sierra wildflower species known as Jewelflowers, from the genus Streptanthus and related species.

As part of this project we (meaning Megan with help from many others including John) examined how different species germination rate is affected by tempserature and water potential.

The data for water potential zero is shown in this plot:

Each subplot is a different population. Species are denoted by the four letters (e.g. CAAM).  Numbers are appended when there are more than one population per species (e.g. STPO1, STPO2, STPO3).  Different colored lines represent different species.

For this week's assignment we want to model the effect of tempserature on germination rate for the different species/populations.

Handcuffs are off, I am going to let you decide what types of models to use.  (But you might want to look at 11.4 "Censoring and Survival" and 12.1 "Over-dispersed counts" and maybe 12.2 "Zero-inflated outcomes".).  

In the data sheet:

pops: species/population
temps: tempserature
wps: water potential
date: date of observation
total_seeds: number of seeds plated for the experiment
germ: the number of germinants found on this day
day: day of the observation relative to start date of the experiment

### 1.  Subset the data to only include wps==0.  We may look at water potential in a future week.

```{r}
data_wps0 <- data %>%
  filter(wps == 0)
head(data_wps0)
summary(data_wps0)
str(data_wps0)
```


### 2. Let's start with a single pop "STDI".  Evaluate models relate germination rate to tempserature.  Explain your model choice and prior choice.  Try to do this both with ulam and brm.

```{r}
data_wps0_STDI <- data_wps0 %>%
  filter(pops == "STDI")
head(data_wps0_STDI)
summary(data_wps0_STDI)
str(data_wps0_STDI)
```
```{r}
ggplot(data_wps0_STDI, aes(x = day, y = cumulative_germ, color = as.factor(temps))) +
  geom_line() +
  geom_point()
```
```{r}
ggplot(data_wps0_STDI, aes(x = day, y = cumulative_prop_germ, color = as.factor(temps))) +
  geom_line() +
  geom_point()
```
```{r}
data_wps0_STDI %>% filter(day==28) %>%
  ggplot(aes(x=temps,y=cumulative_germ)) +
  geom_col()
```

we need one event per row:

```{r}
one_per_row <- function(df) {
  total_seed <- max(df$total_seeds, sum(df$germ))
  newdata <- tibble(id=1:total_seed, germ=0, day=max(df$day))
  df <- df %>% filter(germ>0)
  count <- 1
  if (nrow(df) > 0) {
    for (i in 1:nrow(df)) { # we look at each row of the df where dataination occured
      for (j in 1:df$germ[i]) { # now update the newdata to reflect the germiantion of each seed
        newdata$germ[count] <- 1
        newdata$day[count]=df$day[i]
        count <- count+1 # count keeps track of which individual we are at in the new data
      } # for j
    } # for i
  } # if 
  return(newdata)
}
data_wps0_one <- data_wps0 %>% group_by(pops, temps) %>%
  select(-cumulative_germ) %>% # not needed in this encoding (I think...in any case would need to be recalculated)
  nest() %>%
  mutate(newdata=map(data, one_per_row)) %>%
  select(-data) %>%
  unnest(newdata)
head(data_wps0_one)
summary(data_wps0_one)
```

```{r}
data_wps0_one_STDI <- data_wps0_one %>% filter(pops=="STDI") %>% select(-pops)
head(data_wps0_one_STDI)
summary(data_wps0_one_STDI)
```
### rethinking

```{r}
d <- list(Germ=data_wps0_one_STDI$germ, 
          temps=as.numeric(as.factor(data_wps0_one_STDI$temps)),
          day=data_wps0_one_STDI$day)

m1.1 <- ulam(
  alist(
    day | Germ==1 ~ exponential(lambda),
    day | Germ==0 ~ custom(exponential_lccdf( !Y | lambda)),
    lambda <- 1.0 / mu,
    log(mu) <- a[temps],
    a[temps] ~ normal(0,1)),
  data=d,
  chains=4,
  cores = 4
)
```
```{r}
precis(m1.1, depth = 2)
```

The above represent log(mean time to germination)

```{r}
exp(5.45)
exp(2.48)
```

posterior
```{r}
preddata <- expand_grid(temps=1:8, day=1:28)
pred <- link(m1.1, data = preddata)
str(pred)
```

mu is average day to germ, lambda is rate parameter.  neither change over time, of course, so having day doesn't really make sense.

```{r}
preddata$mu <- apply(pred$mu,2,mean)
preddata$low <- apply(pred$mu,2,HPDI)[1,]
preddata$high <- apply(pred$mu, 2, HPDI)[2,]
```

Single temps.  Don't need day
posterior
```{r}
preddata <- expand_grid(temps=3)
pred <- link(m1.1, data = preddata)
str(pred)
```

how to convert to probs? use pexp.

```{r}
predprobs <- pexp(1:28,rate=pred$lambda[1])
```


```{r}
#plot(x=1:28,y=predprobs, type="l") # crashes on plot
```

even though it isn't using day, including day in the prediction data frame will help me keep data in the correct format.  Maybe.

```{r}
preddata <- expand_grid(temps=1:8, day=1:28)
pred <- link(m1.1, data = preddata)
str(pred)
```

```{r}
predresults <- preddata %>%
  mutate(lambda=as.list(as.data.frame(pred$lambda)))
predresults
```

```{r}
predresults <- predresults %>%
  mutate(probs=map2(day, lambda, ~ pexp(.x, .y)),
         mu=map_dbl(probs, mean),
         lower=map_dbl(probs, ~ HPDI(.)[1] %>% unlist()),
         upper=map_dbl(probs, ~ HPDI(.)[2]) %>% unlist())
predresults
```


```{r}
predresults %>% select(-lambda, -probs) %>%
  mutate(temps=factor(temps, labels=as.character(sort(unique(data_wps0_one_STDI$temps))))) %>%
  ggplot(aes(x=day,y=mu,color=temps,group=temps)) +
  geom_line() 
```

Add realdata:

```{r}
stdi.plot <- data_wps0 %>% filter(pops=="STDI") %>% 
  select(day, temps, cumulative_germ, total_seeds) %>%
  mutate(temps=as.factor(temps),
         prop_germ=cumulative_germ/total_seeds)
predresults %>% select(-lambda, -probs) %>%
  mutate(temps=factor(temps, labels=as.character(sort(unique(data_wps0_one_STDI$temps))))) %>%
  ggplot(aes(x=day,y=mu,color=temps,group=temps)) +
  geom_line() +
  geom_point(aes(y=prop_germ), data=stdi.plot)
```

Poor!

### brms censoring model

need to set up indicator for censoring.
```{r}
data_wps0_one_STDI <- data_wps0_one_STDI %>%
  mutate(cens=ifelse(germ==0, "right", "none"),
         tempsc=as.character(temps) %>% str_pad(width=2, pad="0"))
data_wps0_one_STDI
```

```{r}
get_prior(day | cens(cens) ~ 0 + tempsc, family = exponential, data=data_wps0_one_STDI)
```

### exponential model
```{r}
m1.2 <- brm(day | cens(cens) ~ 0 + tempsc,
            family = exponential(),
            set_prior("normal(0,1)", class="b"),
            data = data_wps0_one_STDI, )
```

```{r}
summary(m1.2)
```


```{r}
predict(m1.2) %>% head
```
log(mean time to germination)

```{r}
predict(m1.2, newdata = expand_grid(tempsc=unique(data_wps0_one_STDI$tempsc), cens=c("none", "right")))
```

```{r}
precis(m1.1, depth = 2)
```
again, these are log(mean time to germination)

lambda should be 1/mu, so

```{r}
plot(1:28,pexp(1:28, 1/exp(2.48)), type="l", col="red")
lines(1:28,pexp(1:28, 1/exp(5.60)), type="l", col="blue")
#crashes
```


```{r}
get_prior( day | cens(cens) ~ 0 + tempsc,
           family = Gamma(),
           data = data_wps0_one_STDI)
```

### Gamma model
```{r}
m1.3 <- brm(day | cens(cens) ~ 0 + tempsc,
            family = Gamma(),
            set_prior("normal(0,1)", class="b", lb=0),
            data = data_wps0_one_STDI)
```

```{r}
summary(m1.3)
```

```{r}
newdata <- expand_grid(tempsc=unique(data_wps0_one_STDI$tempsc), cens=c("none", "right"))
cbind(newdata, predict(m1.3, newdata = newdata))
```

The problem with these models is that they assume that the censored observations are controlled by the same process that is controlling the ones that do germinate.  I do not think that is correct, we need a mixture model.

## Trying a mixture model for a ZI exponential

look at ulam censored exponential
```{r}
rethinking::stancode(m1.1)
```

look at brms censored exponential
```{r}
stancode(m1.2)
```

Zero inflated, as generated by ulam:
```{r}
# define parameters
prob_drink <- 0.2 # 20% of days
rate_work <- 1 # average 1 manuscript per day
# sample one year of production 
N <- 365
# simulate days monks drink 
set.seed(365)
drink <- rbinom( N , 1 , prob_drink )
# simulate manuscripts completed
y <- (1-drink)*rpois( N , rate_work )
rethinking::stancode(ulam( alist(
  y|y>0 ~ custom( log1m(p) + poisson_lpmf(y|lambda) ),
  y|y==0 ~ custom( log_mix( p , 0 , poisson_lpmf(0|lambda) ) ),
  logit(p) <- ap,
  log(lambda) <- al,
  ap ~ dnorm(-1.5,1),
  al ~ dnorm(1,0.5)),
  data=list(y=as.integer(y)) , sample=FALSE))
```

Zero inflated exponential model, attempt 1
```{r}
d <- list(N=nrow(data_wps0_one_STDI),
          germ=data_wps0_one_STDI$germ,
          temps=as.numeric(as.factor(data_wps0_one_STDI$temps)),
          day=data_wps0_one_STDI$day)
stanmodel1.4 <-
  "
data{
    int<lower=1> N;  // number of observations
    int germ[N];
    vector[N] day;
    int temps[N];
}
parameters{
    vector[8] a; // alphas for the linear model
    real ap; // probability of drink
}
model{
    real p;
    vector[N] lambda;
    vector[N] mu;
    a ~ normal( 0 , 1 );
    ap ~ normal( 0, 1 );
    p = ap;
    p = inv_logit(p); // inverse link function for probability drink
    for ( i in 1:N ) {
        mu[i] = a[temps[i]]; // linear model for mu
        mu[i] = exp(mu[i]);  // inverse link function part 1
        lambda[i] = 1/mu[i]; // inverse link function part 2
    }
    for ( i in 1:N ) 
        if ( germ[i] == 0 ) target += log_mix(p, 0, exponential_lccdf(day[i] | lambda[i]));
    for ( i in 1:N ) 
        if ( germ[i] == 1 ) target += log1m(p) +  exponential_lpdf(day[i] | lambda[i]);
    for ( i in 1:N ) 
        if ( germ[i] == 1 ) day[i] ~ exponential( lambda[i] );
}
"
m1.4 <- stan(model_code=stanmodel1.4, data=d)
```

```{r}
precis(m1.4, depth = 2)
```

Model 1.4 fits a single dormancy rate for all, but probably we need to have separate dormancy rate for each temp

take a look at stancode for a binomial model to see what this looks like

### 3. now expand the data set to all species/populations.  Include species/pop (use "pops" as the predictor, don't worry about having a separate predictor for pops nested within species).  is partial pooling appropriate here?
