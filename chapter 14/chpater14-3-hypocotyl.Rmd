---
title: "chapter14-3-hypocotyl"
author: "Min-Yao"
date: "2020/3/19"
output: 
  html_document: 
    keep_md: yes
---

```{r}
library(rethinking)
hyp <- read.csv("hyp.lengths.both.experiments.labels.csv")
head(hyp)
summary(hyp)
str(hyp)
```

### 1. without pooling_base

```{r}
library(dplyr)
hyp_s <- sample_n(hyp, 100)
summary(hyp_s)
str(hyp_s)


dat_list1 <- list(
  length = scale(hyp_s$length),
  line = as.integer(as.factor(hyp_s$line)),
  light = as.integer(hyp_s$light=="H")
)


modle_base <- ulam(
  alist(
    length ~ dnorm(mu, sigma),
    mu <- a[line] + bI[line]*light,
    a[line] ~ dnorm(0, 1),
    bI[line] ~ dnorm(0, 1),
    sigma ~ dexp(1)
  ), data=dat_list1 , chains=4 , cores=4 , log_lik=TRUE)

precis( modle_base, depth=2 , pars=c("bI","sigma"))
plot( precis(modle_base) )
```

```{r}
library(tidyverse)
hyp_s_new <- hyp_s %>% unite("plate_exp", c("plate", "exp"), remove = FALSE)
#head(hyp_s_new)
str(hyp_s_new)

dat_list <- list(
  length = scale(hyp_s_new$length),
  line = as.integer(as.factor(hyp_s_new$line)),
  light = as.integer(hyp_s_new$light=="H"),
  plate_exp = as.integer(as.factor(hyp_s_new$plate_exp))
)

#head(dat_list)
summary(dat_list)
str(dat_list)
```

### 1.without pooling_fixed

```{r}
modle_fixed <- ulam(
  alist(
    length ~ dnorm(mu, sigma),
    mu <- a[line] + bI[line]*light + bP[plate_exp],
    a[line] ~ dnorm(0, 1),
    bI[line] ~ dnorm(0, 1),
    bP[plate_exp] ~ dnorm(0, 1),
    sigma ~ dexp(1)
  ), data=dat_list , chains=4 , cores=4 , log_lik=TRUE)

precis( modle_fixed, depth=2 , pars=c("bI","sigma"))
plot( precis(modle_fixed) )
```

### 2.partial pooling across plate_exp

```{r}
modle_multilevel <- ulam(
  alist(
    length ~ dnorm(mu, sigma),
    mu <- a[line] + bI[line]*light + bP[plate_exp],
    a[line] ~ dnorm(a_bar, sigma_a),
    bI[line] ~ dnorm(0, 1),
    bP[plate_exp] ~ dnorm(0, sigma_p),
    a_bar ~ dnorm( 0 , 1 ),
    sigma_a ~ dexp(1),
    sigma_p ~ dexp(1),
    sigma ~ dexp(1)
  ), data=dat_list , chains=4 , cores=4 , log_lik=TRUE)

precis( modle_multilevel, depth=2 , pars=c("bI","sigma"))
plot(precis( modle_multilevel ))
```

```{r}
compare(modle_base, modle_fixed, modle_multilevel)
plot(compare(modle_base, modle_fixed, modle_multilevel))
```

### 3.As 2, but use a multivariate normal model for the line slope and intercept effects

```{r}
modle_base_multivariate <- ulam(
    alist(
        length ~ normal(mu, sigma),
        mu <- a[line] + bI[line]*light,
        c(a,bI)[line] ~ multi_normal( c(a_bar,b_bar) , Rho , sigma_line ),
        a_bar ~ normal(0,1),
        b_bar ~ normal(0,1),
        sigma_line ~ exponential(1),
        sigma ~ exponential(1),
        Rho ~ lkj_corr(2)
    ) , data=dat_list1 , chains=4 , cores=4, log_lik = TRUE )

precis(modle_base_multivariate, depth=3 , pars=c("Rho","sigma_line"))
```

```{r}
compare(modle_base, modle_fixed, modle_multilevel,modle_base_multivariate)
plot(compare(modle_base, modle_fixed, modle_multilevel,modle_base_multivariate))
```

```{r}
modle_fixed_multivariate <- ulam(
    alist(
        length ~ normal(mu, sigma),
        mu <- a[line] + bI[line]*light + bP[plate_exp],
        c(a,bI)[line] ~ multi_normal( c(a_bar,b_bar) , Rho , sigma_line ),
        a_bar ~ normal(0,1),
        b_bar ~ normal(0,1),
        bP[plate_exp] ~ dnorm(0, 1),
        sigma_line ~ exponential(1),
        sigma ~ exponential(1),
        Rho ~ lkj_corr(2)
    ) , data=dat_list , chains=4 , cores=4, log_lik = TRUE )

precis(modle_fixed_multivariate, depth=3 , pars=c("Rho","sigma_line"))
```

```{r}
compare(modle_base, modle_fixed, modle_multilevel,modle_base_multivariate,modle_fixed_multivariate)
plot(compare(modle_base, modle_fixed, modle_multilevel,modle_base_multivariate,modle_fixed_multivariate))
```

### multivariate normal model with varying slopes model

```{r}
dat_list2 <- list(
  length = scale(hyp_s$length),
  line = as.integer(as.factor(hyp_s$line)),
  light = ifelse(hyp_s$light=="H", 1L , 2L )
)
head(dat_list2)

modle_base_multivariate_varying_slope <- ulam(
    alist(
        length ~ normal(mu, sigma),
        mu <- g[line] + alpha[light,line],

        # adaptive priors
        vector[180]:alpha[light] ~ multi_normal(0,Rho_line,sigma_line),

        # fixed priors
        g[line] ~ dnorm( 0 , 1 ),
        sigma_line ~ dexp(1),
        Rho_line ~ dlkjcorr(4),
        sigma ~ dexp(1)
    ), data=dat_list2 , chains=4 , cores=4 , log_lik = TRUE)

precis(modle_base_multivariate_varying_slope, depth=2)
```

```{r}
dat_list3 <- list(
  length = scale(hyp_s_new$length),
  line = as.integer(as.factor(hyp_s_new$line)),
  light = ifelse(hyp_s$light=="H", 1L , 2L ),
  plate_exp = as.integer(as.factor(hyp_s_new$plate_exp))
)
summary(dat_list3)

modle_base_multivariate_varying_slope_2 <- ulam(
    alist(
        length ~ normal(mu, sigma),
        mu <- g[line] + alpha[light,line] + beta[plate_exp,line],

        # adaptive priors
        vector[180]:alpha[light] ~ multi_normal(0,Rho_line,sigma_line),
        vector[180]:beta[plate_exp] ~ multi_normal(0,Rho_plate_exp,sigma_plate_exp),

        # fixed priors
        g[line] ~ dnorm( 0 , 1 ),
        sigma_line ~ dexp(1),
        Rho_line ~ dlkjcorr(4),
        sigma_plate_exp ~ dexp(1),
        Rho_plate_exp ~ dlkjcorr(4),
        sigma ~ dexp(1)
    ) , data=dat_list3 , chains=4 , cores=4 )
```


### non-centered multivariate normal model with varying slopes model

```{r}
## R code 14.19
modle_base_multivariate_varying_slope_non_centered <- ulam(
    alist(
        length ~ normal(mu, sigma),
        logit(p) <- g[tid] + alpha[actor,tid] + beta[block_id,tid],

        # adaptive priors - non-centered
        transpars> matrix[actor,4]:alpha <-
                compose_noncentered( sigma_actor , L_Rho_actor , z_actor ),
        transpars> matrix[block_id,4]:beta <-
                compose_noncentered( sigma_block , L_Rho_block , z_block ),
        matrix[4,actor]:z_actor ~ normal( 0 , 1 ),
        matrix[4,block_id]:z_block ~ normal( 0 , 1 ),

        # fixed priors
        g[tid] ~ normal(0,1),
        vector[4]:sigma_actor ~ dexp(1),
        cholesky_factor_corr[4]:L_Rho_actor ~ lkj_corr_cholesky( 2 ),
        vector[4]:sigma_block ~ dexp(1),
        cholesky_factor_corr[4]:L_Rho_block ~ lkj_corr_cholesky( 2 ),

        # compute ordinary correlation matrixes from Cholesky factors
        gq> matrix[4,4]:Rho_actor <<- multiply_lower_tri_self_transpose(L_Rho_actor),
        gq> matrix[4,4]:Rho_block <<- multiply_lower_tri_self_transpose(L_Rho_block)
    ) , data=dat , chains=4 , cores=4 , log_lik=TRUE )
```

```{r}
## R code 14.19
modle_base_multivariate_varying_slope_non_centered <- ulam(
    alist(
        length ~ normal(mu, sigma),
        logit(p) <- g[tid] + alpha[actor,tid] + beta[block_id,tid],

        # adaptive priors - non-centered
        transpars> matrix[actor,4]:alpha <-
                compose_noncentered( sigma_actor , L_Rho_actor , z_actor ),
        transpars> matrix[block_id,4]:beta <-
                compose_noncentered( sigma_block , L_Rho_block , z_block ),
        matrix[4,actor]:z_actor ~ normal( 0 , 1 ),
        matrix[4,block_id]:z_block ~ normal( 0 , 1 ),

        # fixed priors
        g[tid] ~ normal(0,1),
        vector[4]:sigma_actor ~ dexp(1),
        cholesky_factor_corr[4]:L_Rho_actor ~ lkj_corr_cholesky( 2 ),
        vector[4]:sigma_block ~ dexp(1),
        cholesky_factor_corr[4]:L_Rho_block ~ lkj_corr_cholesky( 2 ),

        # compute ordinary correlation matrixes from Cholesky factors
        gq> matrix[4,4]:Rho_actor <<- multiply_lower_tri_self_transpose(L_Rho_actor),
        gq> matrix[4,4]:Rho_block <<- multiply_lower_tri_self_transpose(L_Rho_block)
    ) , data=dat , chains=4 , cores=4 , log_lik=TRUE )
```

